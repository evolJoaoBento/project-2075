import { DiceSettings } from './settings';
export declare class D20Dice {
    private scene;
    private camera;
    private renderer;
    private dice;
    private diceBody;
    private world;
    private isRolling;
    private container;
    private animationId;
    private rollTimeout;
    private isDragging;
    private dragStartPosition;
    private mouse;
    private raycaster;
    private lastMousePosition;
    private mouseVelocity;
    private isHoveringDice;
    private diceGeometry;
    private faceNumbers;
    private faceNormals;
    private settings;
    private diceArray;
    private diceBodyArray;
    private diceTypeArray;
    private selectedDice;
    private draggedDiceIndex;
    private trayMesh;
    private windowBorder;
    private hoverCircle;
    private hoverCircleMaterial;
    private floorHeight;
    private forceClickthroughMode;
    onRollComplete: ((result: number | string) => void) | null;
    private ambientLight;
    private directionalLight;
    constructor(container: HTMLElement, settings: DiceSettings);
    private init;
    private initPhysics;
    private createDiceTray;
    private createDice;
    private createDiceGeometry;
    private createD10PolyhedronGeometry;
    private applyD10UVMapping;
    private createPentagonalTrapezohedronGeometry;
    private applyTriangleUVMapping;
    private applyTetrahedronUVMapping;
    private applySquareUVMapping;
    private applyD12PentagonUVMapping;
    private getFaceCountForDiceType;
    createSingleDice(diceType: string): void;
    private createGeometryForDiceType;
    private applyUVMappingForDiceType;
    private createMaterialForDiceType;
    private getDiceTextureDataForType;
    private getDiceNormalMapDataForType;
    private loadTextureFromData;
    private loadNormalMapFromData;
    private createPhysicsBodyForDiceType;
    private createPhysicsShapeForDiceType;
    private getNextDicePosition;
    clearAllDice(): void;
    removeSingleDice(diceType: string): boolean;
    private getRandomResultForDiceType;
    private checkSingleDiceSettling;
    private completeSingleDiceRoll;
    private checkMultiDiceSettling;
    private completeMultiRoll;
    private forceStopMultiRoll;
    private checkDiceResult;
    private getTopFaceNumberForDice;
    private getFaceNormalsForDiceType;
    private mapFaceIndexToNumber;
    private formatRollResults;
    private animateAllDice;
    private createPhysicsBody;
    private createConvexPolyhedronFromGeometry;
    private initializeFaceNumbers;
    private calculateFaceNormals;
    private calculateBoxFaceNormals;
    private calculateCylinderFaceNormals;
    private calculateDodecahedronFaceNormals;
    private calculateD10FaceNormals;
    private calculateTrapezohedronFaceNormals;
    private addDiceTextures;
    generateUVTemplate(): string;
    logColorMapping(): void;
    private getCurrentDiceTextureData;
    private getFaceCount;
    private loadCustomTexture;
    private getCurrentDiceNormalMapData;
    private loadNormalMap;
    private setupLighting;
    private setupDragControls;
    private updateMousePosition;
    private onMouseDown;
    private onTouchStart;
    private onMouseMove;
    private onMouseEnter;
    private onMouseLeave;
    private onTouchMove;
    private onMouseUp;
    private onTouchEnd;
    private checkDiceClick;
    private deleteDiceAtIndex;
    private startDragSingleDice;
    private startDragAllDice;
    private updateDicePosition;
    private throwDice;
    private forceStop;
    private animate;
    private rollResolve;
    private multiRollResolve;
    private rollTimeoutId;
    private showingResult;
    private calculateResult;
    private calculateRotationForTopFace;
    debugPhysics(): void;
    private debugFaceDetectionDistances;
    private calculateRotationToShowFace;
    private getTopFaceNumber;
    private snapDiceToFace;
    private getLowestVertexYForQuaternion;
    private snapToNearestFace;
    private normalizeAngle;
    private setInitialSize;
    updateSize(width: number, height: number): void;
    private reinitializeAfterContextLoss;
    private createWindowBorder;
    private removeWindowBorder;
    updateSettings(newSettings: DiceSettings): void;
    destroy(): void;
    autoCalibrateFace(faceNumber: number): boolean;
    onCalibrationChanged: (() => void) | null;
    setClickthroughMode(enabled: boolean): void;
    private diceStates;
    private currentMonitor;
    private originalMaterials;
    roll(): Promise<string>;
    private initializeDiceStates;
    private applyRollForces;
    private startIndividualDiceMonitoring;
    rerollCaughtDice(): boolean;
    getDiceStatus(): Array<{
        index: number;
        type: string;
        status: string;
        result?: number;
    }>;
    private highlightCaughtDice;
    private clearAllHighlights;
}
