/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/diff-engine.ts
var diff_engine_exports = {};
__export(diff_engine_exports, {
  DiffEngine: () => DiffEngine
});
var DiffEngine;
var init_diff_engine = __esm({
  "src/diff-engine.ts"() {
    DiffEngine = class {
      createDiff(originalContent, newContent, author) {
        const originalParagraphs = this.splitIntoParagraphs(originalContent);
        const newParagraphs = this.splitIntoParagraphs(newContent);
        const suggestions = this.findAdditiveChanges(originalParagraphs, newParagraphs, author, originalContent);
        return {
          suggestions,
          hasChanges: suggestions.length > 0
        };
      }
      splitIntoParagraphs(content) {
        return content.split(/\n\s*\n/).map((p) => p.trim()).filter((p) => p.length > 0).map((p) => this.cleanParagraphContent(p)).filter((p) => p.length > 3);
      }
      cleanParagraphContent(paragraph) {
        return paragraph.replace(/^\s*#+\s*/, "").replace(/^\s*[-*+]\s*/, "").replace(/^\s*\d+\.\s*/, "").replace(/^\s*>\s*/, "").trim();
      }
      findAdditiveChanges(originalParagraphs, newParagraphs, author, originalContent) {
        const suggestions = [];
        const processedNewParagraphs = /* @__PURE__ */ new Set();
        for (let newIndex = 0; newIndex < newParagraphs.length; newIndex++) {
          if (processedNewParagraphs.has(newIndex)) {
            continue;
          }
          const newParagraph = newParagraphs[newIndex];
          let foundEnhancement = false;
          for (let origIndex = 0; origIndex < originalParagraphs.length; origIndex++) {
            const originalParagraph = originalParagraphs[origIndex];
            if (this.isEnhancedVersion(originalParagraph, newParagraph)) {
              suggestions.push({
                type: "addition",
                originalParagraph,
                suggestedParagraph: newParagraph,
                authorAttribution: `***${author}** shared: ${newParagraph}*`,
                position: this.calculateInsertPosition(originalContent, originalParagraph)
              });
              processedNewParagraphs.add(newIndex);
              foundEnhancement = true;
              break;
            }
          }
          if (!foundEnhancement) {
            if (!this.paragraphExistsInOriginal(newParagraph, originalParagraphs) && !this.isShorterVersionOfExisting(newParagraph, originalParagraphs)) {
              suggestions.push({
                type: "addition",
                originalParagraph: "",
                // No original equivalent
                suggestedParagraph: newParagraph,
                authorAttribution: `***${author}** shared: ${newParagraph}*`,
                position: originalContent.length
                // Add at the end
              });
              processedNewParagraphs.add(newIndex);
            }
          }
        }
        return this.removeDuplicateSuggestions(suggestions);
      }
      removeDuplicateSuggestions(suggestions) {
        const uniqueSuggestions = [];
        const seenContent = /* @__PURE__ */ new Set();
        for (const suggestion of suggestions) {
          const key = suggestion.suggestedParagraph + suggestion.originalParagraph;
          if (!seenContent.has(key)) {
            seenContent.add(key);
            uniqueSuggestions.push(suggestion);
          }
        }
        return uniqueSuggestions;
      }
      isEnhancedVersion(original, candidate) {
        const originalWords = this.extractWords(original.toLowerCase());
        const candidateWords = this.extractWords(candidate.toLowerCase());
        if (candidateWords.length <= originalWords.length) {
          return false;
        }
        if (candidateWords.length - originalWords.length < 1) {
          return false;
        }
        let matchingWords = 0;
        for (const word of originalWords) {
          if (candidateWords.includes(word)) {
            matchingWords++;
          }
        }
        const matchRatio = matchingWords / originalWords.length;
        return matchRatio >= 0.7;
      }
      extractWords(text) {
        const cleanedText = text.replace(/#+\s*/g, "").replace(/[*_`~]/g, "").replace(/\[([^\]]*)\]\([^)]*\)/g, "$1").replace(/[^\w\s]/g, " ").toLowerCase();
        return cleanedText.split(/\s+/).filter((word) => word.length > 2).filter((word) => !this.isCommonWord(word)).filter((word) => !/^\d+$/.test(word));
      }
      isCommonWord(word) {
        const commonWords = /* @__PURE__ */ new Set(["the", "and", "but", "for", "are", "was", "his", "her", "you", "all", "can", "had", "not", "now", "one", "our", "out", "two", "way", "who", "boy", "did", "its", "let", "old", "see", "him", "has", "how"]);
        return commonWords.has(word.toLowerCase());
      }
      paragraphExistsInOriginal(paragraph, originalParagraphs) {
        const paragraphWords = this.extractWords(paragraph.toLowerCase());
        for (const original of originalParagraphs) {
          const originalWords = this.extractWords(original.toLowerCase());
          let matchingWords = 0;
          for (const word of paragraphWords) {
            if (originalWords.includes(word)) {
              matchingWords++;
            }
          }
          const similarityRatio = matchingWords / Math.max(paragraphWords.length, originalWords.length);
          if (similarityRatio > 0.6) {
            return true;
          }
        }
        return false;
      }
      isShorterVersionOfExisting(paragraph, originalParagraphs) {
        const paragraphWords = this.extractWords(paragraph.toLowerCase());
        for (const original of originalParagraphs) {
          const originalWords = this.extractWords(original.toLowerCase());
          if (paragraphWords.length < originalWords.length) {
            let matchingWords = 0;
            for (const word of paragraphWords) {
              if (originalWords.includes(word)) {
                matchingWords++;
              }
            }
            const matchRatio = matchingWords / paragraphWords.length;
            if (matchRatio >= 0.7) {
              return true;
            }
          }
        }
        return false;
      }
      calculateInsertPosition(content, targetParagraph) {
        const paragraphs = this.splitIntoParagraphs(content);
        let position = 0;
        for (const paragraph of paragraphs) {
          if (this.paragraphsAreSimilar(paragraph, targetParagraph)) {
            const paragraphEnd = content.indexOf(paragraph, position) + paragraph.length;
            const nextParagraphStart = content.indexOf("\n\n", paragraphEnd);
            return nextParagraphStart === -1 ? content.length : nextParagraphStart + 2;
          }
          position = content.indexOf(paragraph, position) + paragraph.length;
        }
        return content.length;
      }
      paragraphsAreSimilar(para1, para2) {
        const words1 = this.extractWords(para1.toLowerCase());
        const words2 = this.extractWords(para2.toLowerCase());
        if (words1.length === 0 || words2.length === 0)
          return false;
        let matches = 0;
        for (const word of words1) {
          if (words2.includes(word)) {
            matches++;
          }
        }
        return matches / Math.max(words1.length, words2.length) > 0.6;
      }
      applySuggestion(originalContent, suggestion) {
        const spacing = originalContent.endsWith("\n") ? "\n" : "\n\n";
        return originalContent + spacing + suggestion.authorAttribution;
      }
      // Utility method to apply multiple suggestions
      applyMultipleSuggestions(originalContent, suggestions) {
        const sortedSuggestions = [...suggestions].sort((a, b) => b.position - a.position);
        let result = originalContent;
        for (const suggestion of sortedSuggestions) {
          result = this.applySuggestion(result, suggestion);
        }
        return result;
      }
      // Generate a preview of what the merged content would look like
      generatePreview(originalContent, suggestions, selectedSuggestions) {
        const selectedSuggestionsArray = suggestions.filter((_, index) => selectedSuggestions.has(index));
        return this.applyMultipleSuggestions(originalContent, selectedSuggestionsArray);
      }
    };
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NoteSharePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/note-sharer.ts
var NoteSharer = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  async shareNote(file) {
    const content = await this.app.vault.read(file);
    const metadata = this.createMetadata(file, content);
    const sharedNote = {
      filename: file.name,
      content,
      metadata
    };
    return sharedNote;
  }
  createMetadata(file, content) {
    const checksum = this.calculateChecksum(content);
    return {
      author: this.settings.defaultAuthor || "Anonymous",
      timestamp: Date.now(),
      version: "1.0.0",
      originalPath: file.path,
      checksum
    };
  }
  calculateChecksum(content) {
    try {
      let hash = 0;
      for (let i = 0; i < content.length; i++) {
        const char = content.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return hash.toString(36);
    } catch (error) {
      return Date.now().toString(36);
    }
  }
  async shareMultipleNotes(files) {
    const sharedNotes = [];
    for (const file of files) {
      try {
        const sharedNote = await this.shareNote(file);
        sharedNotes.push(sharedNote);
      } catch (error) {
        console.error(`Failed to share note ${file.name}:`, error);
      }
    }
    return sharedNotes;
  }
  validateSharedNote(sharedNote) {
    if (!sharedNote.filename || !sharedNote.content || !sharedNote.metadata) {
      return false;
    }
    if (!sharedNote.metadata.author || !sharedNote.metadata.timestamp || !sharedNote.metadata.checksum) {
      return false;
    }
    const calculatedChecksum = this.calculateChecksum(sharedNote.content);
    return calculatedChecksum === sharedNote.metadata.checksum;
  }
};

// main.ts
init_diff_engine();

// src/merge-modal.ts
var import_obsidian = require("obsidian");
var MergeModal = class extends import_obsidian.Modal {
  constructor(app, sharedNote, existingContent, diff, onMerge) {
    super(app);
    this.selectedSuggestions = /* @__PURE__ */ new Set();
    this.sharedNote = sharedNote;
    this.existingContent = existingContent;
    this.diff = diff;
    this.onMerge = onMerge;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("note-share-modal");
    const headerEl = contentEl.createDiv("note-share-header");
    headerEl.createEl("h2", { text: `Suggestions from ${this.sharedNote.metadata.author}` });
    headerEl.createEl("p", {
      text: `File: ${this.sharedNote.filename} \u2022 Shared: ${new Date(this.sharedNote.metadata.timestamp).toLocaleString()}`,
      cls: "note-share-metadata"
    });
    if (!this.diff.hasChanges) {
      contentEl.createEl("p", {
        text: "No additive changes found. The shared note content already exists in your note.",
        cls: "no-suggestions"
      });
      this.addActionButtons();
      return;
    }
    this.renderSuggestions();
    this.addActionButtons();
    this.addStyles();
  }
  renderSuggestions() {
    const { contentEl } = this;
    const suggestionsEl = contentEl.createDiv("note-share-suggestions");
    suggestionsEl.createEl("h3", { text: `${this.diff.suggestions.length} suggestion(s) found:` });
    this.diff.suggestions.forEach((suggestion, index) => {
      const suggestionEl = suggestionsEl.createDiv("suggestion-item");
      if (this.selectedSuggestions.has(index)) {
        suggestionEl.addClass("accepted");
      }
      const suggestionHeaderEl = suggestionEl.createDiv("suggestion-header");
      const checkbox = suggestionHeaderEl.createEl("input", { type: "checkbox" });
      checkbox.checked = this.selectedSuggestions.has(index);
      checkbox.addEventListener("change", () => {
        if (checkbox.checked) {
          this.selectedSuggestions.add(index);
          suggestionEl.addClass("accepted");
          suggestionEl.removeClass("rejected");
        } else {
          this.selectedSuggestions.delete(index);
          suggestionEl.removeClass("accepted");
          suggestionEl.addClass("rejected");
        }
        this.updateActionButtonStates(suggestionEl, index);
        this.updatePreview();
      });
      const titleEl = suggestionHeaderEl.createDiv("suggestion-title");
      if (suggestion.originalParagraph) {
        titleEl.createEl("span", {
          text: "Enhanced paragraph:",
          cls: "suggestion-type"
        });
      } else {
        titleEl.createEl("span", {
          text: "New content:",
          cls: "suggestion-type"
        });
      }
      if (suggestion.originalParagraph) {
        const originalEl = suggestionEl.createDiv("original-paragraph");
        originalEl.createEl("div", { text: "Your current version:", cls: "paragraph-label" });
        const contentEl2 = originalEl.createDiv("paragraph-content original");
        contentEl2.setText(suggestion.originalParagraph);
      }
      const suggestedEl = suggestionEl.createDiv("suggested-paragraph");
      suggestedEl.createEl("div", { text: "Will be added:", cls: "paragraph-label" });
      const suggestedContentEl = suggestedEl.createDiv("paragraph-content suggested");
      const authorEl = suggestedContentEl.createEl("em");
      authorEl.setText(suggestion.authorAttribution);
      const suggestionActionsEl = suggestionEl.createDiv("suggestion-actions");
      const acceptBtn = new import_obsidian.ButtonComponent(suggestionActionsEl).setButtonText("Accept").onClick(() => {
        this.selectedSuggestions.add(index);
        checkbox.checked = true;
        suggestionEl.addClass("accepted");
        suggestionEl.removeClass("rejected");
        this.updateActionButtonStates(suggestionEl, index);
        this.updatePreview();
      });
      const rejectBtn = new import_obsidian.ButtonComponent(suggestionActionsEl).setButtonText("Reject").onClick(() => {
        this.selectedSuggestions.delete(index);
        checkbox.checked = false;
        suggestionEl.removeClass("accepted");
        suggestionEl.addClass("rejected");
        this.updateActionButtonStates(suggestionEl, index);
        this.updatePreview();
      });
      suggestionEl.setAttribute("data-accept-btn", acceptBtn.buttonEl.outerHTML);
      suggestionEl.setAttribute("data-reject-btn", rejectBtn.buttonEl.outerHTML);
      this.updateActionButtonStates(suggestionEl, index);
    });
  }
  selectAllSuggestions() {
    this.diff.suggestions.forEach((_, index) => {
      this.selectedSuggestions.add(index);
    });
    this.updateAllCheckboxes();
    this.updatePreview();
  }
  clearAllSuggestions() {
    this.selectedSuggestions.clear();
    this.updateAllCheckboxes();
    this.updatePreview();
  }
  updateAllCheckboxes() {
    const checkboxes = this.contentEl.querySelectorAll('input[type="checkbox"]');
    checkboxes.forEach((checkbox, index) => {
      checkbox.checked = this.selectedSuggestions.has(index);
    });
  }
  updateActionButtonStates(suggestionEl, index) {
    const isAccepted = this.selectedSuggestions.has(index);
    const acceptBtn = suggestionEl.querySelector(".suggestion-actions button:first-child");
    const rejectBtn = suggestionEl.querySelector(".suggestion-actions button:last-child");
    if (acceptBtn && rejectBtn) {
      if (isAccepted) {
        acceptBtn.classList.add("mod-cta");
        acceptBtn.style.background = "var(--interactive-accent)";
        acceptBtn.style.color = "var(--text-on-accent)";
        rejectBtn.classList.remove("mod-cta");
        rejectBtn.style.background = "";
        rejectBtn.style.color = "";
      } else {
        acceptBtn.classList.remove("mod-cta");
        acceptBtn.style.background = "";
        acceptBtn.style.color = "";
        rejectBtn.classList.add("mod-warning");
        rejectBtn.style.background = "var(--background-modifier-error)";
        rejectBtn.style.color = "var(--text-on-accent)";
      }
    }
  }
  updatePreview() {
    const applyButton = this.contentEl.querySelector(".apply-button");
    if (applyButton) {
      applyButton.disabled = this.selectedSuggestions.size === 0;
      applyButton.textContent = `Apply ${this.selectedSuggestions.size} suggestion(s)`;
    }
  }
  addActionButtons() {
    const { contentEl } = this;
    const buttonEl = contentEl.createDiv("note-share-buttons");
    const applyButton = new import_obsidian.ButtonComponent(buttonEl).setButtonText(`Apply ${this.selectedSuggestions.size} suggestion(s)`).setCta().onClick(async () => {
      await this.applyMerge();
    });
    applyButton.buttonEl.addClass("apply-button");
    applyButton.buttonEl.disabled = this.selectedSuggestions.size === 0;
    new import_obsidian.ButtonComponent(buttonEl).setButtonText("Cancel").onClick(() => {
      this.close();
    });
  }
  async applyMerge() {
    try {
      const selectedSuggestionsArray = this.diff.suggestions.filter(
        (_, index) => this.selectedSuggestions.has(index)
      );
      const diffEngine = new (await Promise.resolve().then(() => (init_diff_engine(), diff_engine_exports))).DiffEngine();
      const mergedContent = diffEngine.applyMultipleSuggestions(this.existingContent, selectedSuggestionsArray);
      await this.onMerge(mergedContent);
      this.close();
    } catch (error) {
      console.error("Error applying merge:", error);
    }
  }
  addStyles() {
    const style = document.createElement("style");
    style.textContent = `
			.note-share-modal {
				width: 95vw;
				max-width: 1400px;
				height: 85vh;
				max-height: 900px;
				overflow: hidden;
				display: flex;
				flex-direction: column;
			}

			.modal-content {
				width: 100%;
				height: 100%;
				display: flex;
				flex-direction: column;
				overflow: hidden;
			}

			.note-share-header {
				border-bottom: 2px solid var(--background-modifier-border);
				padding-bottom: 15px;
				margin-bottom: 20px;
			}

			.note-share-header h2 {
				margin: 0 0 8px 0;
				color: var(--text-normal);
			}

			.note-share-metadata {
				color: var(--text-muted);
				font-size: 0.9em;
				margin: 0;
			}

			.no-suggestions {
				text-align: center;
				color: var(--text-muted);
				font-style: italic;
				padding: 40px 20px;
			}

			.note-share-quick-actions {
				display: flex;
				gap: 10px;
				margin-bottom: 20px;
				padding: 10px;
				background: var(--background-secondary);
				border-radius: 6px;
			}

			.note-share-suggestions {
				flex: 1;
				overflow-y: auto;
				overflow-x: hidden;
				max-height: 60vh;
				margin-bottom: 20px;
				padding-right: 10px;
				width: 100%;
				box-sizing: border-box;
			}

			.note-share-suggestions h3 {
				margin-top: 0;
				margin-bottom: 15px;
				color: var(--text-normal);
			}

			.suggestion-item {
				border: 1px solid var(--background-modifier-border);
				border-radius: 8px;
				margin-bottom: 12px;
				padding: 12px;
				background: var(--background-primary);
				width: 100%;
				box-sizing: border-box;
			}

			.suggestion-item:hover {
				border-color: var(--interactive-accent);
			}

			.suggestion-item.accepted {
				border-color: var(--interactive-accent);
				background: var(--background-modifier-success);
			}

			.suggestion-item.rejected {
				border-color: var(--background-modifier-error);
				background: var(--background-secondary);
				opacity: 0.7;
			}

			.suggestion-header {
				display: flex;
				align-items: center;
				gap: 10px;
				margin-bottom: 12px;
			}

			.suggestion-header input[type="checkbox"] {
				width: 16px;
				height: 16px;
			}

			.suggestion-title {
				flex: 1;
			}

			.suggestion-type {
				font-weight: 600;
				color: var(--text-accent);
			}

			.original-paragraph,
			.suggested-paragraph {
				margin: 8px 0;
				width: 100%;
				box-sizing: border-box;
				overflow: hidden;
			}

			.paragraph-label {
				font-size: 0.85em;
				font-weight: 500;
				color: var(--text-muted);
				margin-bottom: 5px;
			}

			.paragraph-content {
				padding: 10px;
				border-radius: 4px;
				font-family: var(--font-text);
				font-size: 0.9em;
				line-height: 1.4;
				white-space: pre-wrap;
				word-break: break-word;
				overflow-wrap: anywhere;
				max-width: calc(100% - 20px);
				overflow-x: auto;
				overflow-y: hidden;
			}

			.paragraph-content.original {
				background: var(--background-secondary);
				border-left: 4px solid var(--text-muted);
			}

			.paragraph-content.suggested {
				background: var(--background-modifier-success);
				border-left: 4px solid var(--interactive-accent);
				font-style: italic;
			}

			.suggestion-actions {
				display: flex;
				gap: 6px;
				margin-top: 10px;
				flex-wrap: wrap;
			}

			.suggestion-actions button {
				padding: 3px 10px;
				font-size: 0.8em;
				white-space: nowrap;
				min-width: 60px;
			}

			.note-share-buttons {
				display: flex;
				justify-content: flex-end;
				gap: 10px;
				border-top: 1px solid var(--background-modifier-border);
				padding-top: 15px;
			}

			.apply-button:disabled {
				opacity: 0.5;
				cursor: not-allowed;
			}
		`;
    document.head.appendChild(style);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/share-protocol.ts
var import_obsidian2 = require("obsidian");
var ShareProtocol = class {
  constructor(app) {
    this.PACKAGE_VERSION = "1.0.0";
    this.app = app;
  }
  async exportSharedNote(sharedNote) {
    const sharePackage = {
      version: this.PACKAGE_VERSION,
      notes: [sharedNote],
      timestamp: Date.now(),
      packageId: this.generatePackageId()
    };
    const packageData = JSON.stringify(sharePackage, null, 2);
    await this.savePackageToFile(packageData, `${sharedNote.filename}.noteshare`);
  }
  async exportMultipleNotes(sharedNotes) {
    const sharePackage = {
      version: this.PACKAGE_VERSION,
      notes: sharedNotes,
      timestamp: Date.now(),
      packageId: this.generatePackageId()
    };
    const packageData = JSON.stringify(sharePackage, null, 2);
    const filename = `${sharedNotes.length}-notes-${Date.now()}.noteshare`;
    await this.savePackageToFile(packageData, filename);
  }
  async importSharedNote() {
    try {
      const packageData = await this.loadPackageFromFile();
      if (!packageData) {
        return null;
      }
      const sharePackage = this.parsePackage(packageData);
      if (!sharePackage) {
        new import_obsidian2.Notice("Invalid share package format");
        return null;
      }
      if (sharePackage.notes.length === 0) {
        new import_obsidian2.Notice("No notes found in share package");
        return null;
      }
      if (sharePackage.notes.length === 1) {
        return sharePackage.notes[0];
      }
      return await this.selectNoteFromPackage(sharePackage.notes);
    } catch (error) {
      new import_obsidian2.Notice(`Error importing shared note: ${error.message}`);
      console.error("Import error:", error);
      return null;
    }
  }
  async savePackageToFile(packageData, filename) {
    try {
      const blob = new Blob([packageData], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const downloadLink = document.createElement("a");
      downloadLink.href = url;
      downloadLink.download = filename;
      downloadLink.style.display = "none";
      document.body.appendChild(downloadLink);
      downloadLink.click();
      document.body.removeChild(downloadLink);
      URL.revokeObjectURL(url);
      new import_obsidian2.Notice(`Share package saved as ${filename}`);
    } catch (error) {
      throw new Error(`Failed to save share package: ${error.message}`);
    }
  }
  async loadPackageFromFile() {
    return new Promise((resolve) => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".noteshare,.json";
      input.style.display = "none";
      input.onchange = (event) => {
        var _a, _b;
        const file = (_b = (_a = event.target) == null ? void 0 : _a.files) == null ? void 0 : _b[0];
        if (!file) {
          resolve(null);
          return;
        }
        const reader = new FileReader();
        reader.onload = (e) => {
          var _a2;
          resolve((_a2 = e.target) == null ? void 0 : _a2.result);
        };
        reader.onerror = () => {
          resolve(null);
        };
        reader.readAsText(file);
      };
      input.addEventListener("cancel", () => {
        resolve(null);
      });
      document.body.appendChild(input);
      input.click();
      document.body.removeChild(input);
    });
  }
  parsePackage(packageData) {
    try {
      const parsed = JSON.parse(packageData);
      if (!parsed.version || !parsed.notes || !Array.isArray(parsed.notes)) {
        return null;
      }
      for (const note of parsed.notes) {
        if (!this.isValidSharedNote(note)) {
          return null;
        }
      }
      return parsed;
    } catch (error) {
      console.error("Error parsing package:", error);
      return null;
    }
  }
  isValidSharedNote(note) {
    return typeof note.filename === "string" && typeof note.content === "string" && note.metadata && typeof note.metadata.author === "string" && typeof note.metadata.timestamp === "number" && typeof note.metadata.checksum === "string";
  }
  async selectNoteFromPackage(notes) {
    return new Promise((resolve) => {
      const modal = new NoteSelectionModal(this.app, notes, resolve);
      modal.open();
    });
  }
  generatePackageId() {
    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
  }
  // Utility methods for different sharing mechanisms
  async copyToClipboard(sharedNote) {
    const sharePackage = {
      version: this.PACKAGE_VERSION,
      notes: [sharedNote],
      timestamp: Date.now(),
      packageId: this.generatePackageId()
    };
    const packageData = JSON.stringify(sharePackage);
    await navigator.clipboard.writeText(packageData);
    new import_obsidian2.Notice("Note copied to clipboard");
  }
  async importFromClipboard() {
    try {
      const clipboardText = await navigator.clipboard.readText();
      const sharePackage = this.parsePackage(clipboardText);
      if (!sharePackage) {
        new import_obsidian2.Notice("Clipboard does not contain a valid share package");
        return null;
      }
      if (sharePackage.notes.length === 1) {
        return sharePackage.notes[0];
      }
      return await this.selectNoteFromPackage(sharePackage.notes);
    } catch (error) {
      new import_obsidian2.Notice("Error reading from clipboard");
      console.error("Clipboard import error:", error);
      return null;
    }
  }
  generateShareableLink(sharedNote) {
    const sharePackage = {
      version: this.PACKAGE_VERSION,
      notes: [sharedNote],
      timestamp: Date.now(),
      packageId: this.generatePackageId()
    };
    const packageData = JSON.stringify(sharePackage);
    const encoded = btoa(packageData);
    return `obsidian://note-share/import/${encoded}`;
  }
  async importFromLink(shareUrl) {
    try {
      const urlParts = shareUrl.split("/");
      const encodedData = urlParts[urlParts.length - 1];
      const packageData = atob(encodedData);
      const sharePackage = this.parsePackage(packageData);
      if (!sharePackage) {
        new import_obsidian2.Notice("Invalid share link");
        return null;
      }
      if (sharePackage.notes.length === 1) {
        return sharePackage.notes[0];
      }
      return await this.selectNoteFromPackage(sharePackage.notes);
    } catch (error) {
      new import_obsidian2.Notice("Error importing from share link");
      console.error("Link import error:", error);
      return null;
    }
  }
};
var NoteSelectionModal = class {
  constructor(app, notes, resolve) {
    this.handleKeydown = (e) => {
      if (e.key === "Escape") {
        this.close();
        this.resolve(null);
      }
    };
    this.app = app;
    this.notes = notes;
    this.resolve = resolve;
  }
  open() {
    this.modal = document.createElement("div");
    this.modal.className = "modal";
    this.modal.style.cssText = `
			position: fixed;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: rgba(0, 0, 0, 0.5);
			display: flex;
			align-items: center;
			justify-content: center;
			z-index: 1000;
		`;
    const content = document.createElement("div");
    content.className = "modal-content";
    content.style.cssText = `
			background: var(--background-primary);
			padding: 20px;
			border-radius: 8px;
			max-width: 600px;
			max-height: 80vh;
			overflow-y: auto;
			border: 1px solid var(--background-modifier-border);
		`;
    const header = content.createEl("h2", { text: "Select Note to Import" });
    const noteList = content.createEl("div");
    this.notes.forEach((note, index) => {
      const noteItem = noteList.createEl("div");
      noteItem.style.cssText = `
				padding: 10px;
				border: 1px solid var(--background-modifier-border);
				border-radius: 4px;
				margin: 10px 0;
				cursor: pointer;
			`;
      noteItem.createEl("div", { text: note.filename, cls: "note-title" }).style.fontWeight = "bold";
      noteItem.createEl("div", { text: `Author: ${note.metadata.author}` }).style.color = "var(--text-muted)";
      noteItem.createEl("div", {
        text: `Shared: ${new Date(note.metadata.timestamp).toLocaleString()}`
      }).style.color = "var(--text-muted)";
      noteItem.addEventListener("click", () => {
        this.close();
        this.resolve(note);
      });
      noteItem.addEventListener("mouseenter", () => {
        noteItem.style.background = "var(--background-modifier-hover)";
      });
      noteItem.addEventListener("mouseleave", () => {
        noteItem.style.background = "";
      });
    });
    const buttonContainer = content.createEl("div");
    buttonContainer.style.cssText = "text-align: right; margin-top: 20px;";
    const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
    cancelButton.style.cssText = "margin-left: 10px; padding: 8px 16px;";
    cancelButton.addEventListener("click", () => {
      this.close();
      this.resolve(null);
    });
    this.modal.appendChild(content);
    document.body.appendChild(this.modal);
    this.modal.addEventListener("click", (e) => {
      if (e.target === this.modal) {
        this.close();
        this.resolve(null);
      }
    });
    document.addEventListener("keydown", this.handleKeydown);
  }
  close() {
    if (this.modal && this.modal.parentNode) {
      this.modal.parentNode.removeChild(this.modal);
      document.removeEventListener("keydown", this.handleKeydown);
    }
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  defaultAuthor: "",
  includeMetadata: true,
  autoBackup: true
};
var NoteSharePlugin = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.noteSharer = new NoteSharer(this.app, this.settings);
    this.diffEngine = new DiffEngine();
    this.shareProtocol = new ShareProtocol(this.app);
    this.addRibbonIcon("share", "Share Note", () => {
      this.shareActiveNote();
    });
    this.addRibbonIcon("download", "Import Shared Note", () => {
      this.importSharedNote();
    });
    this.addCommand({
      id: "share-note",
      name: "Share current note",
      callback: () => {
        this.shareActiveNote();
      }
    });
    this.addCommand({
      id: "import-shared-note",
      name: "Import shared note",
      callback: () => {
        this.importSharedNote();
      }
    });
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        if (file instanceof import_obsidian3.TFile && file.extension === "md") {
          menu.addItem((item) => {
            item.setTitle("Share note").setIcon("share").onClick(() => {
              this.shareNote(file);
            });
          });
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file, source) => {
        if (!file || file && file.children) {
          menu.addItem((item) => {
            item.setTitle("Import shared note here").setIcon("download").onClick(() => {
              this.importSharedNote();
            });
          });
        }
      })
    );
    this.addSettingTab(new NoteShareSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async shareActiveNote() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      new import_obsidian3.Notice("No active note to share");
      return;
    }
    await this.shareNote(activeFile);
  }
  async shareNote(file) {
    try {
      const sharedNote = await this.noteSharer.shareNote(file);
      await this.shareProtocol.exportSharedNote(sharedNote);
      new import_obsidian3.Notice(`Note "${file.basename}" prepared for sharing`);
    } catch (error) {
      new import_obsidian3.Notice(`Error sharing note: ${error.message}`);
      console.error("Error sharing note:", error);
    }
  }
  async importSharedNote() {
    try {
      const sharedNote = await this.shareProtocol.importSharedNote();
      if (!sharedNote) {
        return;
      }
      const existingFile = this.app.vault.getAbstractFileByPath(sharedNote.filename);
      if (existingFile instanceof import_obsidian3.TFile) {
        const existingContent = await this.app.vault.read(existingFile);
        const diff = this.diffEngine.createDiff(existingContent, sharedNote.content, sharedNote.metadata.author);
        const mergeModal = new MergeModal(
          this.app,
          sharedNote,
          existingContent,
          diff,
          async (mergedContent) => {
            await this.app.vault.modify(existingFile, mergedContent);
            new import_obsidian3.Notice(`Note "${sharedNote.filename}" merged successfully`);
          }
        );
        mergeModal.open();
      } else {
        await this.app.vault.create(sharedNote.filename, sharedNote.content);
        new import_obsidian3.Notice(`Note "${sharedNote.filename}" imported successfully`);
      }
    } catch (error) {
      new import_obsidian3.Notice(`Error importing note: ${error.message}`);
      console.error("Error importing note:", error);
    }
  }
};
var NoteShareSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Note Share Settings" });
    new import_obsidian3.Setting(containerEl).setName("Default Author").setDesc("Your name to include when sharing notes").addText((text) => text.setPlaceholder("Enter your name").setValue(this.plugin.settings.defaultAuthor).onChange(async (value) => {
      this.plugin.settings.defaultAuthor = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Include Metadata").setDesc("Include frontmatter and metadata when sharing notes").addToggle((toggle) => toggle.setValue(this.plugin.settings.includeMetadata).onChange(async (value) => {
      this.plugin.settings.includeMetadata = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Auto Backup").setDesc("Automatically backup original notes before merging").addToggle((toggle) => toggle.setValue(this.plugin.settings.autoBackup).onChange(async (value) => {
      this.plugin.settings.autoBackup = value;
      await this.plugin.saveSettings();
    }));
  }
};
